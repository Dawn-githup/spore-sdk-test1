"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectCapacityAndPayFee = exports.payFee = exports.payFeeByMinFeeRate = exports.getMinFeeRate = void 0;
const common_scripts_1 = require("@ckb-lumos/common-scripts");
const lumos_1 = require("@ckb-lumos/lumos");
const capacity_1 = require("./capacity");
/**
 * Get minimal acceptable fee rate from RPC.
 */
async function getMinFeeRate(rpc) {
    const info = await rpc.txPoolInfo();
    return lumos_1.BI.from(info.minFeeRate);
}
exports.getMinFeeRate = getMinFeeRate;
/**
 * Pay transaction fee by getting the minimal acceptable fee rate from the RPC.
 */
async function payFeeByMinFeeRate(props) {
    // Env
    const config = props.config;
    const rpc = new lumos_1.RPC(config.ckbNodeUrl);
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Get minimal accepted fee rate from the rpc
    const minFeeRate = await getMinFeeRate(rpc);
    // Pay fee
    txSkeleton = await common_scripts_1.common.payFeeByFeeRate(txSkeleton, props.fromInfos, minFeeRate, void 0, {
        config: props.config.lumos,
    });
    return txSkeleton;
}
exports.payFeeByMinFeeRate = payFeeByMinFeeRate;
/**
 * Pay fee by minimal acceptable fee rate from the RPC,
 * of pay fee by a manual fee rate.
 */
async function payFee(props) {
    if (props.feeRate) {
        return await common_scripts_1.common.payFeeByFeeRate(props.txSkeleton, props.fromInfos, props.feeRate, void 0, {
            config: props.config.lumos,
        });
    }
    else {
        return await payFeeByMinFeeRate(props);
    }
}
exports.payFee = payFee;
/**
 * Inject needed amount of capacity,
 * and then pay fee by minimal acceptable fee rate or by a manual fee rate.
 */
async function injectCapacityAndPayFee(props) {
    const injectNeededCapacityResult = await (0, capacity_1.injectNeededCapacity)({
        ...props,
        config: props.config.lumos,
    });
    const txSkeleton = await payFee({
        ...props,
        txSkeleton: injectNeededCapacityResult.txSkeleton,
    });
    const inputs = txSkeleton.get('inputs').toArray();
    const outputs = txSkeleton.get('outputs').toArray();
    return {
        txSkeleton,
        before: injectNeededCapacityResult.before,
        after: (0, capacity_1.createCapacitySnapshot)(inputs, outputs),
    };
}
exports.injectCapacityAndPayFee = injectCapacityAndPayFee;
//# sourceMappingURL=fee.js.map