"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClusterCellByOutPoint = exports.getClusterCellByType = exports.injectLiveClusterCell = exports.injectClusterIds = exports.injectNewClusterOutput = void 0;
const codec_1 = require("@ckb-lumos/codec");
const lumos_1 = require("@ckb-lumos/lumos");
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const helpers_1 = require("../../helpers");
const config_1 = require("../../config");
const helpers_2 = require("../../helpers");
const codec_2 = require("../../codec");
function injectNewClusterOutput(props) {
    // Env
    const config = props.config;
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Create cluster cell
    const cluster = (0, config_1.getSporeConfigScript)(config, 'Cluster');
    const clusterCell = (0, helpers_1.correctCellMinimalCapacity)({
        cellOutput: {
            capacity: '0x0',
            lock: props.toLock,
            type: {
                ...cluster.script,
                args: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
            },
        },
        data: codec_1.bytes.hexify(codec_2.ClusterData.pack({
            name: codec_1.bytes.bytifyRawString(props.clusterData.name),
            description: codec_1.bytes.bytifyRawString(props.clusterData.description),
        })),
    });
    // Add to Transaction.outputs
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
        return outputs.push(clusterCell);
    });
    // Fix the output's index to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        return fixedEntries.push({
            field: 'outputs',
            index: outputIndex,
        });
    });
    // Generate Cluster Id if possible
    const firstInput = txSkeleton.get('inputs').first();
    if (firstInput) {
        txSkeleton = injectClusterIds({
            clusterOutputIndices: [outputIndex],
            txSkeleton,
            config,
        });
    }
    // Add cluster required dependencies
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, cluster.cellDep);
    return {
        txSkeleton,
        outputIndex,
        hasId: firstInput !== void 0,
    };
}
exports.injectNewClusterOutput = injectNewClusterOutput;
function injectClusterIds(props) {
    let txSkeleton = props.txSkeleton;
    // Get the first input
    const inputs = txSkeleton.get('inputs');
    const firstInput = inputs.get(0);
    if (!firstInput) {
        throw new Error('Cannot generate Cluster Id because Transaction.inputs[0] does not exist');
    }
    // Get ClusterType script
    const cluster = (0, config_1.getSporeConfigScript)(props.config, 'Cluster');
    // Calculates type id by group
    let outputs = txSkeleton.get('outputs');
    let typeIdGroup = (0, helpers_1.generateTypeIdGroup)(firstInput, outputs.toArray(), (cell) => {
        return !!cell.cellOutput.type && (0, helpers_2.isScriptIdEquals)(cell.cellOutput.type, cluster.script);
    });
    // If `clusterOutputIndices` is provided, filter the result
    if (props.clusterOutputIndices) {
        typeIdGroup = typeIdGroup.filter(([typeIdIndex]) => {
            const index = props.clusterOutputIndices.findIndex((index) => index === typeIdIndex);
            return index >= 0;
        });
        if (typeIdGroup.length !== props.clusterOutputIndices.length) {
            throw new Error('Cannot generate Cluster Id because clusterOutputIndices cannot be fully handled');
        }
    }
    // Update results
    for (const [index, typeId] of typeIdGroup) {
        const output = outputs.get(index);
        if (!output) {
            throw new Error(`Cannot generate Cluster Id because Transaction.outputs[${index}] does not exist`);
        }
        output.cellOutput.type.args = typeId;
        outputs = outputs.set(index, output);
    }
    return txSkeleton.set('outputs', outputs);
}
exports.injectClusterIds = injectClusterIds;
async function injectLiveClusterCell(props) {
    // Env
    const clusterCell = props.clusterCell;
    const config = props.config;
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Check target cell type
    const cluster = (0, config_1.getSporeConfigScript)(config, 'Cluster');
    if (!clusterCell.cellOutput.type || !(0, helpers_2.isScriptIdEquals)(clusterCell.cellOutput.type, cluster.script)) {
        throw new Error('Cannot inject live cluster because target cell type is invalid');
    }
    // Add cluster cell to Transaction.inputs
    const setupCellResult = await (0, helpers_1.setupCell)({
        txSkeleton,
        input: props.clusterCell,
        addOutput: props.addOutput,
        updateOutput: props.updateOutput,
        since: props.since,
        config: config.lumos,
        defaultWitness: props.defaultWitness,
    });
    txSkeleton = setupCellResult.txSkeleton;
    // If added to outputs, fix the cell's output index
    if (props.addOutput) {
        txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
            return fixedEntries.push({
                field: 'outputs',
                index: setupCellResult.outputIndex,
            });
        });
    }
    // Add cluster required cellDeps
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, cluster.cellDep);
    return {
        txSkeleton,
        inputIndex: setupCellResult.inputIndex,
        outputIndex: setupCellResult.outputIndex,
    };
}
exports.injectLiveClusterCell = injectLiveClusterCell;
async function getClusterCellByType(clusterType, config) {
    // Env
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    // Get cell by type
    const cell = await (0, helpers_1.getCellByType)({
        type: clusterType,
        indexer,
    });
    if (cell === void 0) {
        throw new Error('Cannot find Cluster by Type because target cell does not exist');
    }
    // Check target cell's type script
    const cluster = (0, config_1.getSporeConfigScript)(config, 'Cluster');
    if (!cell.cellOutput.type || !(0, helpers_2.isScriptIdEquals)(cell.cellOutput.type, cluster.script)) {
        throw new Error('Cannot find cluster by OutPoint because target cell type is invalid');
    }
    return cell;
}
exports.getClusterCellByType = getClusterCellByType;
async function getClusterCellByOutPoint(clusterOutPoint, config) {
    // Env
    const rpc = new lumos_1.RPC(config.ckbNodeUrl);
    // Get cell from rpc
    const cellWithStatus = await (0, helpers_1.getCellWithStatusByOutPoint)({
        outPoint: clusterOutPoint,
        rpc,
    });
    if (cellWithStatus.status !== 'live') {
        throw new Error('Cannot find Cluster by OutPoint because target cell is not lived');
    }
    // Check target cell's type script
    const cluster = (0, config_1.getSporeConfigScript)(config, 'Cluster');
    if (!cellWithStatus.cell.cellOutput.type || !(0, helpers_2.isScriptIdEquals)(cellWithStatus.cell.cellOutput.type, cluster.script)) {
        throw new Error('Cannot find cluster by OutPoint because target cell is not Cluster');
    }
    return cellWithStatus.cell;
}
exports.getClusterCellByOutPoint = getClusterCellByOutPoint;
//# sourceMappingURL=cluster.js.map