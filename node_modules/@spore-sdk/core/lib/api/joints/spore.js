"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSporeCellByOutPoint = exports.getSporeCellByType = exports.injectLiveSporeCell = exports.injectSporeIds = exports.injectNewSporeOutput = void 0;
const codec_1 = require("@ckb-lumos/codec");
const lumos_1 = require("@ckb-lumos/lumos");
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const config_1 = require("../../config");
const helpers_1 = require("../../helpers");
const helpers_2 = require("../../helpers");
const cluster_1 = require("./cluster");
const codec_2 = require("../../codec");
async function injectNewSporeOutput(props) {
    // Env
    const config = props.config;
    const sporeData = props.sporeData;
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // If the creating spore requires a cluster, collect it to inputs/outputs
    let injectClusterCellResult;
    let injectClusterInfo;
    let clusterCell;
    if (sporeData.clusterId) {
        const cluster = (0, config_1.getSporeConfigScript)(config, 'Cluster');
        clusterCell = await (0, cluster_1.getClusterCellByType)({
            ...cluster.script,
            args: sporeData.clusterId,
        }, config);
        // Add dep cluster to Transaction.inputs and Transaction.outputs,
        // but don't change its lock script
        injectClusterCellResult = await (0, cluster_1.injectLiveClusterCell)({
            clusterCell,
            txSkeleton,
            config,
            addOutput: true,
        });
        txSkeleton = injectClusterCellResult.txSkeleton;
        // Record cluster's index info
        injectClusterInfo = {
            inputIndex: injectClusterCellResult.inputIndex,
            outputIndex: injectClusterCellResult.outputIndex,
        };
    }
    // Create spore cell
    const spore = (0, config_1.getSporeConfigScript)(config, 'Spore');
    const sporeCell = (0, helpers_2.correctCellMinimalCapacity)({
        cellOutput: {
            capacity: '0x0',
            lock: props.toLock,
            type: {
                ...spore.script,
                args: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
            },
        },
        data: codec_1.bytes.hexify(codec_2.SporeData.pack({
            contentType: codec_1.bytes.bytifyRawString((0, helpers_1.setContentTypeParameters)(sporeData.contentType, sporeData.contentTypeParameters ?? {})),
            content: sporeData.content,
            clusterId: sporeData.clusterId,
        })),
    });
    // Add to Transaction.outputs
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
        return outputs.push(sporeCell);
    });
    // Fix the spore's output index (and cluster's output index) to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        // Fix the spore's output index to prevent it from future reduction
        fixedEntries = fixedEntries.push({
            field: 'outputs',
            index: outputIndex,
        });
        // Fix the required cluster's output index to prevent it from future reduction
        if (sporeData.clusterId && !!injectClusterCellResult) {
            fixedEntries = fixedEntries.push({
                field: 'outputs',
                index: injectClusterCellResult.outputIndex,
            });
        }
        return fixedEntries;
    });
    // Generate Spore Id if possible
    const firstInput = txSkeleton.get('inputs').first();
    if (firstInput !== void 0) {
        txSkeleton = injectSporeIds({
            sporeOutputIndices: [outputIndex],
            txSkeleton,
            config,
        });
    }
    // Add Spore cellDeps
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, spore.cellDep);
    // Add Cluster cellDeps if exists
    if (clusterCell?.outPoint) {
        txSkeleton = (0, helper_1.addCellDep)(txSkeleton, {
            outPoint: clusterCell.outPoint,
            depType: 'code',
        });
    }
    return {
        txSkeleton,
        outputIndex,
        hasId: firstInput !== void 0,
        cluster: injectClusterInfo ?? void 0,
    };
}
exports.injectNewSporeOutput = injectNewSporeOutput;
function injectSporeIds(props) {
    let txSkeleton = props.txSkeleton;
    // Get the first input
    const inputs = txSkeleton.get('inputs');
    const firstInput = inputs.get(0);
    if (!firstInput) {
        throw new Error('Cannot generate Spore Id because Transaction.inputs[0] does not exist');
    }
    // Get SporeType script
    const spore = (0, config_1.getSporeConfigScript)(props.config, 'Spore');
    // Calculates type id by group
    let outputs = txSkeleton.get('outputs');
    let typeIdGroup = (0, helpers_1.generateTypeIdGroup)(firstInput, outputs.toArray(), (cell) => {
        return !!cell.cellOutput.type && (0, helpers_2.isScriptIdEquals)(cell.cellOutput.type, spore.script);
    });
    // If `sporeOutputIndices` is provided, filter the result
    if (props.sporeOutputIndices) {
        typeIdGroup = typeIdGroup.filter(([typeIdIndex]) => {
            const index = props.sporeOutputIndices.findIndex((index) => index === typeIdIndex);
            return index >= 0;
        });
        if (typeIdGroup.length !== props.sporeOutputIndices.length) {
            throw new Error('Cannot generate Spore Id because sporeOutputIndices cannot be fully handled');
        }
    }
    for (const [index, typeId] of typeIdGroup) {
        const output = outputs.get(index);
        if (!output) {
            throw new Error(`Cannot generate Spore Id because Transaction.outputs[${index}] does not exist`);
        }
        output.cellOutput.type.args = typeId;
        outputs = outputs.set(index, output);
    }
    return txSkeleton.set('outputs', outputs);
}
exports.injectSporeIds = injectSporeIds;
async function injectLiveSporeCell(props) {
    // Env
    const config = props.config;
    const sporeCell = props.sporeCell;
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Check target cell type
    const spore = (0, config_1.getSporeConfigScript)(config, 'Spore');
    if (!sporeCell.cellOutput.type || !(0, helpers_2.isScriptIdEquals)(sporeCell.cellOutput.type, spore.script)) {
        throw new Error('Cannot inject live spore because target cell type is invalid');
    }
    // Add spore to Transaction.inputs
    const setupCellResult = await (0, helpers_1.setupCell)({
        txSkeleton,
        input: sporeCell,
        addOutput: props.addOutput,
        updateOutput: props.updateOutput,
        since: props.since,
        config: config.lumos,
        defaultWitness: props.defaultWitness,
    });
    txSkeleton = setupCellResult.txSkeleton;
    // If added to outputs, fix the cell's output index
    if (props.addOutput) {
        txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
            return fixedEntries.push({
                field: 'outputs',
                index: setupCellResult.outputIndex,
            });
        });
    }
    // Add spore required cellDeps
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, spore.cellDep);
    return {
        txSkeleton,
        inputIndex: setupCellResult.inputIndex,
        outputIndex: setupCellResult.outputIndex,
    };
}
exports.injectLiveSporeCell = injectLiveSporeCell;
async function getSporeCellByType(clusterType, config) {
    // Env
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    // Get cell by type
    const cell = await (0, helpers_2.getCellByType)({
        type: clusterType,
        indexer,
    });
    if (cell === void 0) {
        throw new Error('Cannot find Spore by Type because target cell does not exist');
    }
    // Check target cell's type script
    const spore = (0, config_1.getSporeConfigScript)(config, 'Spore');
    if (!cell.cellOutput.type || !(0, helpers_2.isScriptIdEquals)(cell.cellOutput.type, spore.script)) {
        throw new Error('Cannot find spore by OutPoint because target cell type is invalid');
    }
    return cell;
}
exports.getSporeCellByType = getSporeCellByType;
async function getSporeCellByOutPoint(clusterOutPoint, config) {
    // Env
    const rpc = new lumos_1.RPC(config.ckbNodeUrl);
    // Get cell from rpc
    const cellWithStatus = await (0, helpers_2.getCellWithStatusByOutPoint)({
        outPoint: clusterOutPoint,
        rpc,
    });
    if (cellWithStatus.status !== 'live') {
        throw new Error('Cannot find spore by OutPoint because target cell is not lived');
    }
    // Check target cell's type script
    const spore = (0, config_1.getSporeConfigScript)(config, 'Spore');
    if (!cellWithStatus.cell.cellOutput.type || !(0, helpers_2.isScriptIdEquals)(cellWithStatus.cell.cellOutput.type, spore.script)) {
        throw new Error('Cannot find spore by OutPoint because target cell type is invalid');
    }
    return cellWithStatus.cell;
}
exports.getSporeCellByOutPoint = getSporeCellByOutPoint;
//# sourceMappingURL=spore.js.map