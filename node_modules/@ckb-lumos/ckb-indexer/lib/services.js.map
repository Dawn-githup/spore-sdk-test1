{"version":3,"file":"services.js","names":["generateSearchKey","queries","script","undefined","filter","script_type","script_search_mode","lock","unwrapScriptWrapper","toScript","type","block_range","fromBlock","toBlock","BI","from","add","toString","outputDataLenRange","output_data_len_range","outputCapacityRange","output_capacity_range","scriptLenRange","script_len_range","scriptSearchMode","Error","toSearchKey","getHexStringBytes","hexString","utils","assertHexString","Math","ceil","substr","length","id","requestBatch","rpcUrl","data","res","fetch","method","headers","body","JSON","stringify","map","item","status","result","json","error","requestBatchTransactionWithStatus","txHashes","requestBody","txHash","index","jsonrpc","params","ResultFormatter","toTransactionWithStatus"],"sources":["../src/services.ts"],"sourcesContent":["import { utils, HexString } from \"@ckb-lumos/base\";\nimport { CKBIndexerQueryOptions, SearchKey } from \"./type\";\nimport fetch from \"cross-fetch\";\nimport { BI } from \"@ckb-lumos/bi\";\nimport { toScript } from \"./paramsFormatter\";\nimport type * as RPCType from \"./rpcType\";\nimport { toSearchKey } from \"./resultFormatter\";\nimport { unwrapScriptWrapper } from \"./ckbIndexerFilter\";\nimport { ResultFormatter } from \"@ckb-lumos/rpc\";\nimport { RPC as RpcTypes } from \"@ckb-lumos/rpc/lib/types/rpc\";\nimport { CKBComponents } from \"@ckb-lumos/rpc/lib/types/api\";\n\nconst generateSearchKey = (queries: CKBIndexerQueryOptions): SearchKey => {\n  let script: RPCType.Script | undefined = undefined;\n  const filter: RPCType.SearchFilter = {};\n  let script_type: RPCType.ScriptType | undefined = undefined;\n  let script_search_mode: RPCType.ScriptSearchMode = \"prefix\";\n  if (queries.lock) {\n    const lock = unwrapScriptWrapper(queries.lock);\n    script = toScript(lock);\n    script_type = \"lock\";\n    if (queries.type && typeof queries.type !== \"string\") {\n      const type = unwrapScriptWrapper(queries.type);\n      filter.script = toScript(type);\n    }\n  } else if (queries.type && typeof queries.type !== \"string\") {\n    const type = unwrapScriptWrapper(queries.type);\n    script = toScript(type);\n    script_type = \"type\";\n  }\n  let block_range: RPCType.HexadecimalRange | null = null;\n  if (queries.fromBlock && queries.toBlock) {\n    //toBlock+1 cause toBlock need to be included\n    block_range = [\n      queries.fromBlock,\n      `0x${BI.from(queries.toBlock).add(1).toString(16)}`,\n    ];\n  }\n  if (block_range) {\n    filter.block_range = block_range;\n  }\n  if (queries.outputDataLenRange) {\n    filter.output_data_len_range = queries.outputDataLenRange;\n  }\n  if (queries.outputCapacityRange) {\n    filter.output_capacity_range = queries.outputCapacityRange;\n  }\n  if (queries.scriptLenRange) {\n    filter.script_len_range = queries.scriptLenRange;\n  }\n  if (queries.scriptSearchMode) {\n    script_search_mode = queries.scriptSearchMode;\n  }\n  if (!script) {\n    throw new Error(\"Either lock or type script must be provided!\");\n  }\n  if (!script_type) {\n    throw new Error(\"script_type must be provided\");\n  }\n  return toSearchKey({\n    script,\n    script_type,\n    filter,\n    script_search_mode,\n  });\n};\n\nconst getHexStringBytes = (hexString: HexString): number => {\n  utils.assertHexString(\"\", hexString);\n  return Math.ceil(hexString.substr(2).length / 2);\n};\n\nlet id = 0;\n// will be tested in e2e\n/* c8 ignore next 25 */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function requestBatch<T = any>(\n  rpcUrl: string,\n  // eslint-disable-next-line\n  data: Record<string, unknown>[]\n): Promise<{ result: T; jsonrpc: string; id: number | string }[]> {\n  if (!data.length) {\n    return [];\n  }\n\n  const res = await fetch(rpcUrl, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(data.map((item) => ({ id: id++, ...item }))),\n  });\n  if (res.status !== 200) {\n    throw new Error(`Indexer request failed with HTTP code ${res.status}`);\n  }\n  const result = await res.json();\n  if (result.error !== undefined) {\n    throw new Error(\n      `indexer request rpc failed with error: ${JSON.stringify(result.error)}`\n    );\n  }\n  return result;\n}\n\n/* c8 ignore next 23 */\nasync function requestBatchTransactionWithStatus(\n  rpcUrl: string,\n  txHashes: string[]\n): Promise<CKBComponents.TransactionWithStatus[]> {\n  if (txHashes.length === 0) {\n    return [];\n  }\n  const requestBody = txHashes.map((txHash, index) => {\n    return {\n      id: index,\n      jsonrpc: \"2.0\",\n      method: \"get_transaction\",\n      params: [txHash],\n    };\n  });\n\n  const res = await requestBatch<RpcTypes.TransactionWithStatus>(\n    rpcUrl,\n    requestBody\n  );\n  return res.map((item) =>\n    ResultFormatter.toTransactionWithStatus(item.result)\n  );\n}\n\nexport {\n  generateSearchKey,\n  getHexStringBytes,\n  requestBatch,\n  requestBatchTransactionWithStatus,\n};\n"],"mappings":"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"}